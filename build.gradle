// Needed for extending the "clean" task to also delete custom stuff defined here like natives
apply plugin: 'base'

apply plugin: 'project-report'

// Dependencies needed for what our Gradle scripts themselves use. It cannot be included via an external Gradle file :-(
buildscript {
    repositories {
        // External libs - jcenter is Bintray and is supposed to be a superset of Maven Central, but do both just in case
        jcenter()
        mavenCentral()
    }

    dependencies {
        // Artifactory plugin
        classpath(group: 'org.jfrog.buildinfo', name: 'build-info-extractor-gradle', version: '4.0.0')

        // Git plugin for Gradle
        classpath 'org.ajoberstar:gradle-git:0.6.3'

        // Needed for caching reflected data during builds
        classpath 'org.reflections:reflections:0.9.10'
        classpath 'dom4j:dom4j:1.6.1'
    }
}

// Test for right version of Java in use for running this script
assert org.gradle.api.JavaVersion.current().isJava8Compatible()

// Declare "extra properties" (variables) for the project (and subs) - a Gradle thing that makes them special.
ext {
    dirNatives = 'natives'
    dirConfigMetrics = 'gradle/metrics'
    templatesDir = 'gradle/templates'

    // Lib dir for use in manifest entries etc (like in :engine). A separate "libsDir" exists, auto-created by Gradle
    subDirLibs = 'libs'

    LwjglVersion = '2.9.3'
}

// Declare remote repositories we're interested in - library files will be fetched from here
repositories {
    // External libs - jcenter is Bintray and is supposed to be a superset of Maven Central, but do both just in case
    jcenter()
    mavenCentral()

    // MovingBlocks Artifactory instance for libs not readily available elsewhere plus our own libs
    maven {
        if (rootProject.hasProperty("artifactoryResolveRepo")) {
            url "http://artifactory.terasology.org/artifactory/$artifactoryResolveRepo"
            println "Changing root RESOLVE repo to $artifactoryResolveRepo"
        } else {
            url "http://artifactory.terasology.org/artifactory/virtual-repo-live"
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Natives - Handles pulling in and extracting native libraries for LWJGL                                            //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Define configurations for natives and config
configurations {
    natives
    codeMetrics
}

dependencies {
    // For the "natives" configuration make it depend on the native files from LWJGL
    natives group: 'org.lwjgl.lwjgl', name: 'lwjgl', version: LwjglVersion

    // Config for our code analytics lives in a centralized repo: https://github.com/MovingBlocks/TeraConfig
    codeMetrics group: 'org.terasology.config', name: 'codemetrics', version: '1.1.0', ext: 'zip'
}

task extractWindowsNatives(type:Sync) {
    description = "Extracts the Windows natives from the downloaded zip"
    from {
        configurations.natives.collect { it.getName().contains('-natives-window') ? zipTree(it) : [] }
    }
    into ("$dirNatives/windows")
    exclude ('META-INF/**')
}

task extractMacOSXNatives(type:Sync) {
    description = "Extracts the OSX natives from the downloaded zip"
    from {
        configurations.natives.collect { it.getName().contains('-natives-osx') ? zipTree(it) : [] }
    }
    into ("$dirNatives/macosx")
    exclude ('META-INF/**')
}

task extractLinuxNatives(type:Sync) {
    description = "Extracts the Linux natives from the downloaded zip"
    from {
        configurations.natives.collect { it.getName().contains('-natives-linux') ? zipTree(it) : [] }
    }
    into ("$dirNatives/linux")
    exclude ('META-INF/**')
}

task extractNatives {
    description = "Extracts all the native lwjgl libraries from the downloaded zip"
    dependsOn extractWindowsNatives
    dependsOn extractLinuxNatives
    dependsOn extractMacOSXNatives
}

// TODO: Test meta modules and other libs - not that there's really much to test other than being able to Git via Gradle

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Helper tasks                                                                                                      //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

task extractConfig (type: Copy) {
    description = "Extracts our configuration files from the zip we fetched as a dependency"
    from {
        configurations.codeMetrics.collect {
            zipTree(it)
        }
    }
    into "$rootDir/$dirConfigMetrics"
}

// This is a TEMPORARY tweak to make "changing" dependencies always ('0') check for newer snapshots available
// TODO: Remove this when versioning and promotion works fully, then we shouldn't care about snapshots normally anyway
// For some reason this can stay here, yet had to be removed from everywhere else for Gradle 3.3
configurations.all {
    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
}

// Include deletion of extracted natives in the global clean task. Without the doLast it runs on *every* execution ...
clean.doLast {
    new File(dirNatives).deleteDir()
    new File(dirConfigMetrics).deleteDir()
    println "Cleaned root - don't forget to re-extract stuff! 'gradlew extractNatives extractConfig' will do so, or 'gradlew idea' (or eclipse)"
}

task protobufCompileWindows(type:Exec) {
    description = "Run 'Protobuf Compiler' (Windows)"
    commandLine 'protobuf\\compiler\\protoc.exe', '--proto_path=engine\\src\\main\\protobuf', '--java_out', 'engine\\src\\main\\java', 'engine\\src\\main\\protobuf\\*'
}

task protobufCompileLinux(type:Exec) {
    description = "Run 'Protobuf Compiler' (Linux)"
    commandLine 'protobuf/compiler/protoc', '--proto_path=engine/src/main/protobuf', '--java_out', 'engine/src/main/java', "engine/src/main/protobuf/EntityData.proto", "engine/src/main/protobuf/NetMessage.proto"
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These tasks are written in a way that makes them execute always, outside Gradle's regular workflow of calculating what needs to be done //
// If they were written as Copy tasks and such they'd only work during the execution phase for a run that included them on the task graph  //
// That's how it was done in the frequent 'gradlew idea' days where any change impacting project structure needed a rerun + IDE restart    //
// With Gradle import / linking enabled instead we can use IDE integration to avoid a restart but don't have an explicit task to chain to  //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// TODO: Convert the natives, config, and IDE setup to be tasks like this one
task copyInMissingTemplates {
    description = "Copies in placeholders from the /gradle/templates dir to project root if not present yet"
    File gradlePropsFile = new File(rootDir, 'gradle.properties')
    File OverrideCfgFile = new File(rootDir, 'override.cfg')
    if (!gradlePropsFile.exists()) {
        new File(rootDir, 'gradle.properties') << new File(templatesDir, 'gradle.properties').text
    }
    if (!OverrideCfgFile.exists()) {
        new File(rootDir, 'override.cfg') << new File(templatesDir, 'override.cfg').text
    }
}

// TODO: Consider making this stuff excluded from clean, then offer a fullClean for the rare time that may be needed
// That would allow a `gradlew clean` without having to rerun this at all, everything would still work fine (with rebuild)
task prepareStuff {
    dependsOn extractNatives
    dependsOn extractConfig
    dependsOn copyInMissingTemplates
}

task harnessTheBuild (type: Zip) {
    description = "Prepares all build files and supporting stuff needed to build modules solo"
    dependsOn extractNatives
    dependsOn extractConfig

    from ('modules') {
        include 'build.gradle'
    }

    from ('gradle') {
        include '*.gradle'
        include 'wrapper/**/*'
        include 'metrics/**/*'
        include 'templates/**/*'
        into 'gradle'
    }

    from 'gradlew'
    from 'gradlew.bat'
    from 'groovyw'
    from 'groovyw.bat'
    from 'module.groovy'

    archiveName = "TerasologyHarness.zip"
}

afterEvaluate {
    // This pops up way too early - after this particular file has been evaluated? Module config logging follows
    // Really need a hook to trigger a task's execution phase on any project evaluation
    // Difficulty: IntelliJ uses a special entry point (likely Eclipse as well) that just evaluates somehow
    //println 'After evaluate (TODO: Trying to find a good point to hook in a prep task)'
}

gradle.afterProject {
    // This triggers *a lot* - after every project is evaluated. So similar to allProjects.afterEvaluate?
    //println 'After project (TODO: Trying to find a good point to hook in a prep task)'
}
