// This file holds language-generic Gradle stuff for modules. It is meant to be included by the language specific Gradle files

import groovy.json.JsonSlurper

import org.reflections.Reflections;
import org.reflections.scanners.SubTypesScanner;
import org.reflections.scanners.TypeAnnotationsScanner;
import org.reflections.util.ConfigurationBuilder;

def moduleDepends = [];
def moduleFile = file('module.txt')

println "Scanning for dependencies in module.txt for " + project.name
def slurper = new JsonSlurper()
def moduleConfig = slurper.parseText(moduleFile.text)
for (dependency in moduleConfig.dependencies) {
    if (dependency.id != 'engine') {
        moduleDepends += dependency.id
    }
}
println "Dependencies: $moduleDepends"

// Gradle uses the magic version variable when creating the jar name (unless explicitly set somewhere else I guess)
version = moduleConfig.version

// Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor
group = 'org.terasology.modules'

println "Version for $project.name loaded as $version for group $group"

ext {
    // The base set of directories potentially needed in a module. Language Gradle files add their unique extras
    moduleSkeletonDirs = ['assets',
                          'assets/animations',
                          'assets/atlas',
                          'assets/behaviors',
                          'assets/blocks',
                          'assets/blockSounds',
                          'assets/blockTiles',
                          'assets/fonts',
                          'assets/i18n',
                          'assets/materials',
                          'assets/mesh',
                          'assets/music',
                          'assets/prefabs',
                          'assets/shaders',
                          'assets/shapes',
                          'assets/skeletalMesh',
                          'assets/skins',
                          'assets/sounds',
                          'assets/textures',
                          'assets/ui',
                          'overrides',
                          'deltas']
}

// Set dependencies. Note that the dependency information from module.txt is used for other Terasology modules
dependencies {
    // TODO: Add a new Gradle plugin that itself is responsible for scanning module.txt (actually module.info.json or so)
    // It should contain a method that can be triggered here that will apply the appropriate dependencies for the given module
    // Ideally it could also handle the source vs binary plus outputting nice build info

    // Check to see if this module is not the root Gradle project - if so we are in a multi-project workspace
    if (project.name != project(':').name) {
        println "\nProcessing module '$project.name' in a multi-project workspace"

        // Dependency on the engine itself (actually its built jar file)
        compile project(':engine')

        // Engine unit tests contain classes that module unit tests can extend, so need to be compile, not testCompile
        compile project(':engine-tests')

        if (moduleDepends.size() > 0) {
            println "* $project.name has extra dependencies:"
            moduleDepends.each {
                println "** $it"
            }
        } else {
            println "* No extra dependencies"
        }

        // If the module has dependencies on other modules we look for either a source version or a remote binary
        for (dependency in moduleDepends) {
            File wouldBeSrcPath = new File(rootDir, 'modules/' + dependency)
            //println "Scanning for source module at: " + wouldBeSrcPath.getAbsolutePath()

            // First see if we have an actual source module project in the Gradle project tree (user fetchModule'ed it)
            if (wouldBeSrcPath.exists()) {
                //TODO: This could hit problems with corrupt module directories?

                println "*** Identified source: " + dependency
                // Note: if artifactoryPublish is used in a multi-project workspace including modules the .pom gets hard version refs
                // Normally they're expected to run in Jenkins standalone where they'll instead match the else and get version '+'
                compile project(':modules:' + dependency)
            } else {
                println "*** Seeking as binary: " + dependency
                // The '+' is satisfied by any version. "changing" triggers better checking for updated snapshots
                // TODO: When version handling and promotion is in then we can probably ignore snapshots in normal cases
                compile(group: 'org.terasology.modules', name: dependency, version: '+', changing: true)
            }
        }

        // This step resolves artifacts early, after which project config CANNOT be altered again!
         //TODO: This is what causes the nested task slowdown, due to the resolve at config time issue
        //configurations.compile.resolvedConfiguration.resolvedArtifacts.each { ResolvedArtifact artifact ->
        // TODO: This updated version seems to do the trick without a slowdown! Hunt down any other usage like the old one
        configurations.compile.incoming.afterResolve { ResolvedArtifact artifact ->
            def id = artifact.moduleVersion.id

            // Check for any needed module dependencies on other modules that we need at runtime
            if (id.group == 'org.terasology.modules' && id.name != "Core") {
                File moduleSrcPath = new File(rootDir, 'modules/' + id.name)
                File moduleJarPath = new File(rootDir, 'modules/' + id.name + '-' + id.version + '.jar')

                if (moduleSrcPath.exists()) {
                    println "*** Found module dependency $id.name in source form, not copying a runtime jar from Gradle"
                } else {
                    println "$project.name resolved binary $id.group - $id.name at version $id.version"

                    // This copies the jar from the Gradle cache to the game's module dir for runtime usage, if needed
                    if (!moduleJarPath.exists()) {
                        println "* Writing a runtime jar to /modules: " + moduleJarPath.name
                        moduleJarPath.createNewFile()
                        moduleJarPath << artifact.file.bytes
                    }
                }
            }
        }
    } else {
        println "We're in a single-project non-Core module workspace (Jenkins) so will look elsewhere for dependencies"

        // TODO: While this is easy it would prevent modules declaring an engine dependency of a specific version
        // TODO: Look for a provided engine jar in the workspace and use that if present
        // TODO: Only use engine, engine-tests, and maybe core for compilation, but remove when publishing?
        compile(group: 'org.terasology.engine', name: 'engine', version: '+', changing: true)
        compile(group: 'org.terasology.engine', name: 'engine-tests', version: '+', changing: true)

        // To get Terasology module dependencies we simply declare them against Artifactory
        moduleDepends.each {
            println "*** Attempting to fetch dependency module from Artifactory for " + project.name + ": " + it
            // The '+' is satisfied by any version
            compile(group: 'org.terasology.modules', name: it, version: '+', changing: true)

        }

        // TODO: parse and apply external lib dependencies if any are present
        // TODO: Consider / keep an eye on whether resolving artifacts early at this point causes any trouble (is only for logging)
        // This step resolves artifacts (both compile & testCompile) and prints out some interesting versions

        //configurations.testCompile.resolvedConfiguration.resolvedArtifacts.each { ResolvedArtifact artifact ->
        configurations.testCompile.incoming.afterResolve { ResolvedArtifact artifact -> // Fixed version
            def id = artifact.moduleVersion.id
            // Print out module (and engine stuff) dependencies and the exact versions they resolved at
            if (id.group.startsWith('org.terasology')) {
                println "*** $project.name remotely resolved $id.group - $id.name - version $id.version"
            }
        }
    }
}

task cacheReflections {
    description = 'Caches reflection output to make regular startup faster. May go stale and need cleanup at times.'
    // TODO: The extra "org" qualifier excludes test classes otherwise sucked up in Jenkins, causing issues. Redo later
    File dirToReflect = new File(sourceSets.main.output.classesDir, "org")
    inputs.files dirToReflect
    outputs.file file(sourceSets.main.output.classesDir.toString() + "/reflections.cache")
    dependsOn classes
    doFirst {
        // Without the .mkdirs() we might hit a scenario where the classes dir doesn't exist yet
        dirToReflect.mkdirs()
        Reflections reflections = new Reflections(new ConfigurationBuilder()
                .addUrls(dirToReflect.toURI().toURL())
                .setScanners(new TypeAnnotationsScanner(), new SubTypesScanner()))
        reflections.save(sourceSets.main.output.classesDir.toString() + "/reflections.cache")
    }
}

task cleanReflections(type: Delete) {
    description = 'Cleans the reflection cache. Useful in cases where it has gone stale and needs regeneration.'
    delete sourceSets.main.output.classesDir.toString() + "/reflections.cache"
}

// This task syncs everything in the assets dir into the output dir, used when jarring the module
task syncAssets(type: Sync) {
    from 'assets'
    into 'build/classes/assets'
}

task syncOverrides(type: Sync) {
    from 'overrides'
    into 'build/classes/overrides'
}

task syncDeltas(type: Sync) {
    from 'deltas'
    into 'build/classes/deltas'
}
